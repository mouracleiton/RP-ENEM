{
    "formatVersion": "1.0",
    "exportDate": "2025-11-29T10:30:00.000-0300",
    "appVersion": "1.0",
    "curriculumData": {
      "metadata": {
        "startDate": "2025-01-01",
        "duration": "1 Semestre",
        "dailyStudyHours": "6-8 hours",
        "totalAtomicSkills": 65,
        "version": "1.0 - ITA Catalog 2025 Based",
        "lastUpdated": "2025-11-29",
        "institution": "Instituto Tecnológico de Aeronáutica (ITA)",
        "basedOn": "Catálogo dos Cursos de Graduação 2025 - CC201"
      },
      "areas": [
        {
          "id": "12",
          "name": "Projeto e Análise de Algoritmos",
          "description": "Área dedicada ao estudo avançado de algoritmos, análise de complexidade computacional e técnicas de projeto para resolver problemas computacionais complexos",
          "totalSkills": 65,
          "percentage": 100,
          "disciplines": [
            {
              "id": "12.1",
              "name": "CTC-12: Projeto e Análise de Algoritmos",
              "description": "Disciplina que aborda análise de complexidade, recursividade, paradigmas de programação, algoritmos em grafos, problemas NP-completos e técnicas avançadas de projeto de algoritmos",
              "totalSkills": 65,
              "mainTopics": [
                {
                  "id": "12.1.1",
                  "name": "Análise de Complexidade",
                  "description": "Estudo de ordens de funções, notação assintótica e análise de tempo e espaço de algoritmos",
                  "totalSkills": 10,
                  "atomicTopics": [
                    {
                      "id": "12.1.1.1",
                      "name": "Notação Assintótica",
                      "description": "Uso de Big-O, Omega e Theta para análise de complexidade",
                      "individualConcepts": [
                        {
                          "id": "12.1.1.1.1",
                          "name": "Analisar complexidade de algoritmos iterativos",
                          "description": "Calcular complexidade temporal e espacial de loops aninhados",
                          "specificSkills": [
                            {
                              "id": "12.1.1.1.1.1",
                              "name": "Calcular complexidade de algoritmos com loops aninhados",
                              "description": "Determinar O(n²) para dois loops aninhados e generalizar para k loops",
                              "atomicExpansion": {
                                "steps": [
                                  {
                                    "stepNumber": 1,
                                    "title": "Identificar estruturas de repetição",
                                    "subSteps": [
                                      "Reconhecer loops for, while e do-while",
                                      "Contar número de iterações em cada loop",
                                      "Identificar dependências entre loops"
                                    ],
                                    "verification": "Identifica corretamente todos os loops em um algoritmo dado",
                                    "estimatedTime": "30 minutos",
                                    "materials": ["Material sobre análise de algoritmos", "Exemplos de código"],
                                    "tips": "Desenhe um gráfico das iterações para visualizar o crescimento",
                                    "learningObjective": "Dominar a identificação de estruturas de repetição em algoritmos",
                                    "commonMistakes": ["Esquecer loops internos", "Não considerar condições de parada"]
                                  }
                                ],
                                "practicalExample": "Algoritmo com for(i=0;i<n;i++) { for(j=0;j<n;j++) { ... } } tem complexidade O(n²)",
                                "finalVerifications": [
                                  "Calcula complexidade correta para algoritmos com múltiplos loops",
                                  "Diferencia entre melhor caso, pior caso e caso médio",
                                  "Aplica notação Big-O corretamente"
                                ],
                                "assessmentCriteria": [
                                  "Análise precisa do número de operações",
                                  "Uso correto da notação assintótica",
                                  "Identificação de termos dominantes"
                                ],
                                "crossCurricularConnections": ["Matemática Discreta", "Cálculo", "Otimização"],
                                "realWorldApplication": "Fundamental para otimização de software, escalabilidade de sistemas e seleção de algoritmos apropriados para grandes volumes de dados"
                              },
                              "estimatedTime": "4-6 horas",
                              "difficulty": "intermediate",
                              "status": "not_started",
                              "prerequisites": []
                            }
                          ]
                        }
                      ]
                    }
                  ]
                },
                {
                  "id": "12.1.2",
                  "name": "Recursividade e Recorrências",
                  "description": "Análise de algoritmos recursivos e métodos para resolver equações de recorrência",
                  "totalSkills": 8,
                  "atomicTopics": [
                    {
                      "id": "12.1.2.1",
                      "name": "Método Mestre",
                      "description": "Aplicação do teorema mestre para resolver recorrências da forma T(n) = aT(n/b) + f(n)",
                      "individualConcepts": [
                        {
                          "id": "12.1.2.1.1",
                          "name": "Aplicar método mestre para análise",
                          "description": "Usar o teorema mestre para determinar complexidade de algoritmos recursivos",
                          "specificSkills": [
                            {
                              "id": "12.1.2.1.1.1",
                              "name": "Classificar recorrências usando método mestre",
                              "description": "Identificar caso 1, 2 ou 3 do teorema mestre e calcular T(n)",
                              "atomicExpansion": {
                                "steps": [
                                  {
                                    "stepNumber": 1,
                                    "title": "Identificar parâmetros a, b e f(n)",
                                    "subSteps": [
                                      "Determinar número de subproblemas (a)",
                                      "Identificar fator de redução (b)",
                                      "Analisar função de custo não recursiva f(n)"
                                    ],
                                    "verification": "Extrai corretamente a, b e f(n) de recorrência dada",
                                    "estimatedTime": "40 minutos",
                                    "materials": ["Material sobre método mestre", "Tabela de casos"],
                                    "tips": "Verifique sempre se a recorrência se encaixa na forma T(n) = aT(n/b) + f(n)",
                                    "learningObjective": "Compreender a estrutura das recorrências resolvíveis pelo método mestre",
                                    "commonMistakes": ["Confundir a e b", "Não verificar regularidade de f(n)"]
                                  }
                                ],
                                "practicalExample": "T(n) = 2T(n/2) + n → a=2, b=2, f(n)=n → Caso 2: T(n) = Θ(n log n)",
                                "finalVerifications": [
                                  "Classifica corretamente o caso do método mestre",
                                  "Calcula complexidade assintótica precisa",
                                  "Aplica em algoritmos como MergeSort e QuickSort"
                                ],
                                "assessmentCriteria": [
                                  "Identificação correta dos parâmetros",
                                  "Aplicação precisa do teorema",
                                  "Interpretação do resultado no contexto do algoritmo"
                                ],
                                "crossCurricularConnections": ["Cálculo", "Álgebra", "Análise de Algoritmos"],
                                "realWorldApplication": "Usado na análise de algoritmos de divisão e conquista como MergeSort, QuickSort e algoritmos de multiplicação de matrizes"
                              },
                              "estimatedTime": "5-7 horas",
                              "difficulty": "advanced",
                              "status": "not_started",
                              "prerequisites": ["12.1.1.1.1.1"]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                },
                {
                  "id": "12.1.3",
                  "name": "Paradigmas de Programação",
                  "description": "Abordagens sistemáticas para projeto de algoritmos: divisão e conquista, método guloso e programação dinâmica",
                  "totalSkills": 20,
                  "atomicTopics": [
                    {
                      "id": "12.1.3.1",
                      "name": "Programação Dinâmica",
                      "description": "Técnica para resolver problemas de otimização quebrando-os em subproblemas menores e armazenando soluções",
                      "individualConcepts": [
                        {
                          "id": "12.1.3.1.1",
                          "name": "Resolver problema da mochila 0-1",
                          "description": "Implementar algoritmo de programação dinâmica para o problema de optimização da mochila binária",
                          "specificSkills": [
                            {
                              "id": "12.1.3.1.1.1",
                              "name": "Implementar algoritmo PD para mochila 0-1",
                              "description": "Desenvolver solução ótima usando tabela de programação dinâmica",
                              "atomicExpansion": {
                                "steps": [
                                  {
                                    "stepNumber": 1,
                                    "title": "Compreender a estrutura do problema",
                                    "subSteps": [
                                      "Definir parâmetros: valores, pesos e capacidade",
                                      "Identificar subproblemas sobrepostos",
                                      "Formular a relação de recorrência DP[i][w]"
                                    ],
                                    "verification": "Formula corretamente a recorrência para mochila 0-1",
                                    "estimatedTime": "45 minutos",
                                    "materials": ["Material sobre programação dinâmica", "Exemplos de recorrências"],
                                    "tips": "Desenhe a tabela DP para visualizar os subproblemas e suas dependências",
                                    "learningObjective": "Compreender a decomposição do problema em subproblemas menores",
                                    "commonMistakes": ["Confundir com mochila fracionária", "Esquecer de inicializar a tabela"]
                                  },
                                  {
                                    "stepNumber": 2,
                                    "title": "Implementar e preencher tabela DP",
                                    "subSteps": [
                                      "Inicializar DP[0..n][0..W] com zeros",
                                      "Preencher usando DP[i][w] = max(DP[i-1][w], valor[i] + DP[i-1][w-peso[i]])",
                                      "Rastrear a solução ótima a partir de DP[n][W]"
                                    ],
                                    "verification": "Preenche a tabela DP corretamente para um exemplo dado",
                                    "estimatedTime": "60 minutos",
                                    "materials": ["IDE para codificação", "Casos de teste variados"],
                                    "tips": "Use debugging para verificar cada célula da tabela durante o preenchimento",
                                    "learningObjective": "Implementar eficientemente o algoritmo de PD com complexidade O(nW)",
                                    "commonMistakes": ["Erros de índice na tabela", "Não considerar o caso quando peso > w"]
                                  }
                                ],
                                "practicalExample": "Itens: (v=60, p=10), (v=100, p=20), (v=120, p=30); capacidade=50. Valor máximo = 220 com itens 2 e 3",
                                "finalVerifications": [
                                  "Algoritmo retorna valor máximo correto para vários casos de teste",
                                  "Complexidade O(nW) é atingida na implementação",
                                  "Solução ótima é reconstruída corretamente a partir da tabela"
                                ],
                                "assessmentCriteria": [
                                  "Implementação correta da relação de recorrência",
                                  "Eficiência no uso de espaço e tempo",
                                  "Capacidade de generalizar para variações do problema"
                                ],
                                "crossCurricularConnections": ["Otimização Combinatória", "Pesquisa Operacional", "Inteligência Artificial"],
                                "realWorldApplication": "Aplicado em problemas de alocação de recursos, seleção de investimentos, corte de estoque e sistemas de recomendação"
                              },
                              "estimatedTime": "6-8 horas",
                              "difficulty": "advanced",
                              "status": "not_started",
                              "prerequisites": ["12.1.2.1.1.1"]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                },
                {
                  "id": "12.1.4",
                  "name": "Algoritmos em Grafos",
                  "description": "Algoritmos fundamentais para problemas em grafos: busca, caminhos mínimos, árvores geradoras e fluxo",
                  "totalSkills": 15,
                  "atomicTopics": [
                    {
                      "id": "12.1.4.1",
                      "name": "Algoritmo de Dijkstra",
                      "description": "Algoritmo para encontrar caminhos mais curtos em grafos com pesos não-negativos",
                      "individualConcepts": [
                        {
                          "id": "12.1.4.1.1",
                          "name": "Implementar Dijkstra com heap",
                          "description": "Desenvolver versão eficiente usando estrutura de dados heap",
                          "specificSkills": [
                            {
                              "id": "12.1.4.1.1.1",
                              "name": "Analisar complexidade do Dijkstra com heap binário",
                              "description": "Calcular O((V+E) log V) para implementação com min-heap",
                              "atomicExpansion": {
                                "steps": [
                                  {
                                    "stepNumber": 1,
                                    "title": "Compreender estrutura de heap",
                                    "subSteps": [
                                      "Revisar propriedades de min-heap",
                                      "Entender operações extract-min e decrease-key",
                                      "Analisar custo das operações de heap"
                                    ],
                                    "verification": "Explica custo O(log n) para operações de heap",
                                    "estimatedTime": "35 minutos",
                                    "materials": ["Material sobre heaps", "Visualizações de operações"],
                                    "tips": "Implemente um min-heap from scratch para entender profundamente as operações",
                                    "learningObjective": "Dominar a estrutura de dados heap e suas operações fundamentais",
                                    "commonMistakes": ["Confundir com max-heap", "Errar na implementação de heapify"]
                                  }
                                ],
                                "practicalExample": "Grafo com 5 vértices e 7 arestas com pesos. Aplicar Dijkstra a partir do vértice 1.",
                                "finalVerifications": [
                                  "Calcula caminhos mais curtos corretamente para todos os vértices",
                                  "Complexidade O((V+E) log V) é verificada experimentalmente",
                                  "Implementação mantém invariantes do algoritmo"
                                ],
                                "assessmentCriteria": [
                                  "Uso correto da estrutura heap",
                                  "Manutenção das distâncias durante as operações",
                                  "Eficiência na implementação das operações de heap"
                                ],
                                "crossCurricularConnections": ["Estruturas de Dados", "Otimização", "Redes de Computadores"],
                                "realWorldApplication": "Usado em sistemas de navegação GPS, roteamento em redes, planejamento logístico e sistemas de recomendação de rotas"
                              },
                              "estimatedTime": "5-7 horas",
                              "difficulty": "advanced",
                              "status": "not_started",
                              "prerequisites": ["12.1.3.1.1.1"]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                },
                {
                  "id": "12.1.5",
                  "name": "Problemas NP-Completos",
                  "description": "Estudo da classe NP, problemas NP-completos e técnicas de redução polinomial",
                  "totalSkills": 12,
                  "atomicTopics": [
                    {
                      "id": "12.1.5.1",
                      "name": "Reduções Polinomiais",
                      "description": "Técnicas para transformar um problema NP-completo em outro",
                      "individualConcepts": [
                        {
                          "id": "12.1.5.1.1",
                          "name": "Reduzir SAT para 3-SAT",
                          "description": "Demonstrar que 3-SAT é NP-completo via redução de SAT",
                          "specificSkills": [
                            {
                              "id": "12.1.5.1.1.1",
                              "name": "Construir redução polinomial de SAT para 3-SAT",
                              "description": "Transformar fórmula booleana arbitrária em forma 3-CNF",
                              "atomicExpansion": {
                                "steps": [
                                  {
                                    "stepNumber": 1,
                                    "title": "Compreender formas normais",
                                    "subSteps": [
                                      "Diferenciar entre CNF e 3-CNF",
                                      "Identificar cláusulas com k literais",
                                      "Reconhecer que toda fórmula booleana pode ser convertida para CNF"
                                    ],
                                    "verification": "Converte fórmula simples para CNF",
                                    "estimatedTime": "40 minutos",
                                    "materials": ["Material sobre lógica booleana", "Exemplos de conversões"],
                                    "tips": "Use leis de De Morgan e distributividade para as conversões",
                                    "learningObjective": "Compreender as formas normais na lógica booleana e suas propriedades",
                                    "commonMistakes": ["Não preservar equivalência lógica", "Criar cláusulas desnecessárias"]
                                  }
                                ],
                                "practicalExample": "Converter (x1 ∨ x2 ∨ x3 ∨ x4) para conjunto de cláusulas 3-CNF usando variáveis auxiliares",
                                "finalVerifications": [
                                  "Redução preserva satisfatibilidade",
                                  "Tamanho da instância 3-SAT é polinomial em relação à instância SAT original",
                                  "Conversão é computável em tempo polinomial"
                                ],
                                "assessmentCriteria": [
                                  "Corretude da redução",
                                  "Eficiência da transformação",
                                  "Clareza na explicação dos passos"
                                ],
                                "crossCurricularConnections": ["Lógica Matemática", "Complexidade Computacional", "Teoria da Computação"],
                                "realWorldApplication": "Fundamental para provas de NP-completude, verificação formal de hardware/software e solvers SAT industriais"
                              },
                              "estimatedTime": "6-8 horas",
                              "difficulty": "advanced",
                              "status": "not_started",
                              "prerequisites": ["12.1.4.1.1.1"]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "infographics": null,
      "settings": null
    }
  }
  